

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Architecture General Overview &mdash; Health Gateway 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Health Gateway 1.0 documentation" href="index.html"/>
        <link rel="next" title="HGW Frontend" href="modules/hgw_frontend/home.html"/>
        <link rel="prev" title="Health Gateway Documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Health Gateway
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Architecture General Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#main-components">Main Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="#main-concepts">Main Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#high-level-process-for-a-data-flow-opening">High-level Process for a Data Flow Opening</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preconditions">Preconditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#description">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#architecture">Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pilot-implementation-details">Pilot Implementation Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#control-layer">Control Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#destination-and-source-enrollment">Destination and Source enrollment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#channels-creation">Channels Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#security">Security</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-flow-layer">Data Flow Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overall-data-exchange-process">Overall data exchange process</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">Security</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-encryption">Data Encryption</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#user-authentication">User authentication</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spid">SPID</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ts-cns">TS/CNS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modules/hgw_frontend/home.html">HGW Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules/hgw_backend/home.html">HGW Backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules/consent_manager/home.html">Consent Manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Issues</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Health Gateway</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Architecture General Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/architecture.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="architecture-general-overview">
<h1>Architecture General Overview<a class="headerlink" href="#architecture-general-overview" title="Permalink to this headline">¶</a></h1>
<p>The Health Gateway is a system that has two main objectives:</p>
<ul class="simple">
<li>to allow the establishment of a virtual communication (Channel)
between two systems, the Source and the Destination,
to send medical data related to a person, who has to mediate and
authorize it.</li>
<li>to mediate data delivering from the Source to the Destination according
to the Channels</li>
</ul>
<div class="section" id="main-components">
<h2>Main Components<a class="headerlink" href="#main-components" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The platform main components are:</p>
<ul>
<li><dl class="first docutils">
<dt><strong>Destination</strong></dt>
<dd><p class="first">a Destination is a system where a person would like to forward a set
of their data from a Source.</p>
<blockquote class="last">
<div><ul>
<li><p class="first"><strong>Destination Endpoint (DE)</strong>: it is a module of the Destination
enabling it to receive the data from the authorized Sources.
It is composed of the following subcomponents:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Destination HGW API</strong>: the module which interacts with
the API exposed by the Health Gateway to create, delete
and manage data flows authorized by the person;</li>
<li><strong>Destination Connection Module</strong>: the data driver which
receives the authorized data from the Sources.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Source</strong></dt>
<dd><p class="first">a Source is a system which holds person’s data and is authorized by
the person to release a set of them to Destinations.</p>
<blockquote class="last">
<div><ul>
<li><p class="first"><strong>Source Endpoint (SE)</strong>: it is a module of the Source enabling
it to send the data to the authorized
Destinations. It is composed of the following subcomponents:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Source HGW API</strong>: the module which interacts with the
API exposed by the Health Gateway to create, delete and
manage data flows authorized by the person;</li>
<li><strong>Source Connection Module</strong>: the data connection driver
which retrieve the authorized data from the Source.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Health Gateway (HG)</strong></dt>
<dd><p class="first">The Health Gateway acts as an intermediary to allow a person to
authorize the exchange of his/her data between the Destination
and the Source. It also handles data routing from Sources to
Destinations. It is composed of three sub-components:</p>
<ul class="last simple">
<li><dl class="first docutils">
<dt>Health Gateway Frontend (HGF)</dt>
<dd>it manages the communications with the Destinations; it
exposes an API which enables the person to open,
authorize, modify or delete a data flow, redirecting the
person to the Consent Manager, after their
secure authentication on the Identity Provider;
it notifies the Health Gateway Backend with the results
of the identification/authorization steps to allow the
system to perform and complete the operation
requested by the person (as data flows opening, modification,…);</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Health Gateway Backend (HGB)</dt>
<dd>it manages the communications with the Sources; it receives
the authorized requests for operations to be performed on data
flows (as data flows opening, modification,…) from the Health
Gateway Frontend and forwards them to the Source Endpoint;</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Health Gateway Dispatcher (HGD)</dt>
<dd>it handles data dispatching from Sources to Destinations.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Consent Manager (CM)</strong></dt>
<dd><p class="first last">it is the system that handles the authorization
process. It informs the person about the data that will be
exchanged between a Destination and the Sources and allows
her/him to accept or not the data transfer. It also handles
authorization for modification or revocation.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Identity Provider (IDP)</strong>:</dt>
<dd><p class="first last">the Identity Provider identifies the person and provides their
data to permit the Source to match its persons data to the person
the data flow is related to.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="main-concepts">
<h2>Main Concepts<a class="headerlink" href="#main-concepts" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt><strong>Profile</strong></dt>
<dd>it is a tree data structure (as, for example, an openEHR archetype)
defining what data the person authorizes to be sent to a Destination;</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Channel</strong></dt>
<dd>a Channel is a logical connection between a Source and a Destination
to tranfer data of a certain type belonging to a person. It is defined
by the quadruple: (Source Endpoint, Destination Endpoint, Profile,
Person ID). When a Channel is active the person’s data specified
by the Profile are sent from the Source Endpoint to the Destination
Endpoint.
All channels have a validity time duration range associated to them.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Flow Request</strong></dt>
<dd>It is a request from a Destination to the HGW to start the process
of opening one or more Channel for a Person</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Consent</strong></dt>
<dd>authorization related to a Channel and given by a person, to transfer
their data, as selected by the
channel Profile, from a Source to a Destination.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Connector</strong></dt>
<dd>a Connector is an object, associated to a Channel,
created through a request sent by the HGB to the
Source Endpoint. A Connector enables the delivering of a person’s data,
according to the Profile and Destination of the associated Channel.
Its life-cycle corresponds to the one of the Channel associated: when
it expires the Source Endpoint stops sending the related data.</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="high-level-process-for-a-data-flow-opening">
<h2>High-level Process for a Data Flow Opening<a class="headerlink" href="#high-level-process-for-a-data-flow-opening" title="Permalink to this headline">¶</a></h2>
<div class="section" id="preconditions">
<h3>Preconditions<a class="headerlink" href="#preconditions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>The Destinations are registered as possible data targets in the CM</li>
<li>The Sources are registered as possible data origin in the CM</li>
<li>The HG and the CM are connected to the same IDP which is recognized
by the Sources as a trusted person demographics owner</li>
<li>The Destinations, the Sources and the CM share a set of valid
Profiles among which the person can choose to decide which data she/he wants
to share</li>
</ul>
</div>
<div class="section" id="description">
<h3>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h3>
<p>A person who wants to allow a data flow to a Destination enters in the
Destination user interface, selects the data Profiles and starts the
process to authorize the Destination to receive their clinical data.
The Destination inserts a Flow Request (about the Profile requested)
in the HGF, which redirects the user to the Identity
Provider, to perform the authentication. After that, the HGW instantiates
the Channels (one per known Source Endpoint), creates the corresponding
Consents into to the CM and redirects the user to the
CM
The CM shows the Consents corresponding to the Profile
initially chosen and the user selects the set of authorizations they
want to confirm and the list of data Sources. The CM
activates the Consents and informs the HGF which
activates the Channels and redirects the person’s User Agent to the
Destination. Meanwhile, the HGF sends a request to the
HGB to open Connectors in the Source Endpoints. Before
opening a Connector, the Source Endpoint must query the CM in
order to ensure that there is an active consent for the Connector’s associated
Channel. If the CM confirms there is an active Consent
associated to the Channel, the data flow can begin, according to the
Consent parameters (data profile, duration, …).</p>
</div>
</div>
<div class="section" id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p>The pictures below shows the overall architecture of the system.
The HGW module is connected to all available Sources, on one side,
and to the available Destinations, on the other side.
Every endpoint is part of the correspondent Source and it acts as a
black-box between the backend of the HGW and the Source itself.</p>
<img alt="_images/architecture.svg" src="_images/architecture.svg" /><p>As shown in the detailed architecture diagram below, there are two
different layers of information, and consequently two different sub-layers
of architecture we can identify:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Control Layer</strong>: it concerns all the operations to fulfill to create
and activate the Channels between a Destination and one or more available
Sources for a person.</li>
<li><strong>Data Flows Layer</strong>: it is related to the exchange of clinical data
between the Sources and the HGW and the HGW and the Destinations.</li>
</ul>
</div></blockquote>
<p>The figure below depicts a schema of all the main components
(including both Sources and Destinations sides) and all the involved flows
for the control layer (in red) and the data layer (in blue). All main steps for
both flows are enumerated, and the legend describes the performed operations.
Notice that before data are sent
from the dispatcher to the destination endpoint, a control step (C)
is required, in order to ensure that the channel related to the current
message flow still has a valid consent.</p>
<img alt="_images/architecture_details.svg" src="_images/architecture_details.svg" /></div>
<div class="section" id="pilot-implementation-details">
<h2>Pilot Implementation Details<a class="headerlink" href="#pilot-implementation-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="control-layer">
<h3>Control Layer<a class="headerlink" href="#control-layer" title="Permalink to this headline">¶</a></h3>
<p>The <strong>Control Layer</strong> concerns all the operations to fulfill to create and
activate the Channels between a Destination and one or more available
Sources for a person. It is based on communications between the
components of the system which is illustrated in the figure below:</p>
<img alt="_images/component_communications.svg" src="_images/component_communications.svg" /><p>As we can see we have two type of communications:</p>
<ul>
<li><p class="first"><strong>REST communication</strong>: it means that the services exposes REST endpoints
to perform some actions. This kind of communication is used for:</p>
<blockquote>
<div><ul class="simple">
<li>Flow Request creation from the DE to the HGF</li>
<li>Consents creation from HGF to CM</li>
<li>Connector creation from the HGB to a SE</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>Messaging</strong>: when an operation is asynchronous the Control Layer uses
messaging with a message broker. Kafka is the broker of choice, but others
can be used.
This type of communications is used for:</p>
<blockquote>
<div><ul class="simple">
<li>Consents notification: used by the CM to notify to the HGF
changes about the Consents status</li>
<li>Channels notification: used by the HGF to notify to the HGB
changes about Channels</li>
<li>Connector notification: used by the HGB to notify to the HGF
changes about Connector</li>
<li>Source notification: used by the HGB to synchronize Sources
database in HGF. Infact, the master of the Sources’ database is
the HGB, but the HGF uses its own copy with fewer details about
the Sources.</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="section" id="destination-and-source-enrollment">
<h4>Destination and Source enrollment<a class="headerlink" href="#destination-and-source-enrollment" title="Permalink to this headline">¶</a></h4>
<p>The Health Gateway can interact only with known Destinations and Sources.
This means that they all have to be registered in the Health Gateway.
In order to be enrolled, a Destination must be granted and validated
by an Authority, which the Health Gateway trusts. This Authority releases
a pair of key/certificate to the Destination.
As a result of the enrollment process, Destinations and Sources obtain
different kind of data.
Destinations will have:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>OAuth2 credentials:</dt>
<dd>a client_id and a client_secret, that must be kept secret, needed
to obtain OAuth2 tokens to interact with the REST API;</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>RSA private/public key pair:</dt>
<dd>this are needed for the data payload encryption. The private key must
be kept secret by the destination, while the public key is sent to
the Sources to encrypt the messages payload</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>destination_id:</dt>
<dd>it is an ID that identifies the Destination in the HGW. It is also
the Kafka topic name assigned to the Destination;</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Kafka client certs:</dt>
<dd>key/certs to use to connect to Kafka. Kafka is indeed configured
using HTTPS and to accept connections only by known clients.</dd>
</dl>
</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NB: The <code class="docutils literal notranslate"><span class="pre">`destination_id`</span></code> and the Kafka client certs are needed only when
the destination wants to retrieve messages using a Kafka consumer</p>
</div>
<p>Sources will have:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>source_id:</dt>
<dd>it is an ID that identifies the Source in the HGW. Is is also the
Kafka topic assigned to the Source where it sends the data</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Kafka client certs:</dt>
<dd>key/certs to use to connect to Kafka. As for the Destinations also
the Sources needs a them to connect to Kafka</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="channels-creation">
<h4>Channels Creation<a class="headerlink" href="#channels-creation" title="Permalink to this headline">¶</a></h4>
<p>The process of Channel(s) creation is performed in two phases, the first
involving the User and the secondo asynchronously</p>
<p>The following sequence diagram describes the first phase</p>
<img alt="_images/channel_instantiation_1.svg" src="_images/channel_instantiation_1.svg" /><p>The operations are the following:</p>
<blockquote>
<div><ul class="simple">
<li>The person enters the Destination web page with a User and starts
the process to authorize the Destination to get their clinical data</li>
<li>The Destination creates a Flow Request in the HGF,
specifying the Profile, a <cite>callback_url</cite>, which is a url where the
User will be redirected at the end of the process, and
the <cite>flow_id</cite> which is an identifier of the Flow Request
created by the Destination. It is possible to specify a subset of the
Sources to be considered for the request.</li>
<li>The HGF sets the Flow Request in PENDING status until
the user authorizes it. It returns to the Destination a <cite>process_id</cite>
and a <cite>confirmation_id</cite>: the <cite>process_id</cite> is the identifier of the
Flow Request in the HGF and it will be used as the identifier of the
messages sent to the Destination referring to the Channels created;
the <cite>confirmation_id</cite> is a temporary ID that the Destination needs to
include as parameter to the HGF confirmation URL to confirm
the request.</li>
<li>The Destination redirects the User to the HGF
confirmation url specifying the confirmation ID.</li>
<li>The HGF redirects the User to the IDP
service to perform the authentication</li>
<li>The IDP authenticates the person and sends to the
HGF their demographics</li>
<li>The HGF creates a Channel for every Source and for every
Channel calls the CM to create a corresponding Consent.
The Channel is set to <code class="docutils literal notranslate"><span class="pre">CONSENT_REQUESTED</span> <span class="pre">(CR)</span></code> status, while the
Consent is set to <code class="docutils literal notranslate"><span class="pre">PENDING</span></code> status by the CM</li>
<li>The CM returns a temporary <cite>confirmation_id</cite> to be sent to
its confirmation url,
in a similar way as done for the Flow Request confirmation.</li>
<li>The HGF redirects the User to the Consent
Manager confirmation url.</li>
<li>The CM redirects the User again to the IDP
to identify the person. This time the person doesn’t need
to perform the login since they are already logged in.</li>
<li>The CM shows the Consents that the user has to confirm
and the user selects the set of authorizations they want to
confirm and the list of Sources to authorize.</li>
<li>The CM sets the Consents to ACTIVE state and redirects
the User to the HGF
which redirects again to the Destination callback page</li>
</ul>
<p>From User’s point of view the process is done, but at this moment,
the Channel object is not ACTIVE (i.e., the clinical documents related
to the Channel are not sent from the Source to the Destination).
In fact only the corresponding Consent
has been set to ACTIVE and the Source has not been notified about the
Channel creation. To complete the Channel activation, the
asynchronous communication among the CM, the HGF and the HGB starts.
The following sequence diagram describes the second phase</p>
<img alt="_images/channel_instantiation_2.svg" src="_images/channel_instantiation_2.svg" /><p>The operation are the following:</p>
<ul class="simple">
<li>The CM sends a Consent Update message to the Health
Gateway Frontend notifying that the Consent has been confirmed by
the User</li>
<li>The HGF sets the Channel’s status to
<code class="docutils literal notranslate"><span class="pre">WAITING_SOURCE_NOTIFICATION</span> <span class="pre">(WS)</span></code>, which means that it is waiting that
the Source is notified about the Channel creation event</li>
<li>The HGF sends a message to the Health Gateway
Backend with the data of the Channel</li>
<li>The HGB receives the message and calls the REST endpoint
of the SE to create a Connector.</li>
<li>The SE, before accepting the Connector creation, queries the
CM to check if there actually is an active Consent for the Connector</li>
<li>If the operation is accomplished, the HGB send a message to the
HGF, notifying that the Source has been connected correctly</li>
<li>The HGF sets the Channel status to ACTIVE</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="security">
<h4>Security<a class="headerlink" href="#security" title="Permalink to this headline">¶</a></h4>
<p>The Control Layer is secured by using HTTPS connection for all the
communications among the components. Also, the HGF and the
CM are secured using OAuth2 client-credentials
authentication (<a class="reference external" href="https://tools.ietf.org/html/rfc6749#section-4.4">https://tools.ietf.org/html/rfc6749#section-4.4</a>).
This means that a DE has to obtain an OAuth2 access token,
before continuing the process of Flow Request creation.
The Source Endpoint is also required to implement an authentication
mechanism for the HGB, for example using OAuth2 or
client certificates.</p>
</div>
</div>
<div class="section" id="data-flow-layer">
<h3>Data Flow Layer<a class="headerlink" href="#data-flow-layer" title="Permalink to this headline">¶</a></h3>
<p>The <strong>Data Flows Layer</strong> is related to the transfer of clinical data
between Sources and HGW and the HGW and the Destinations, and it is
based on Kafka.
The HGW acts as a Kafka Consumer for all data provided by the Sources
(producers), and acts as a Kafka Producer when providing data to the
Destinations.
A topic for each different Source (with a well defined ID) will be created.
Some key aspects about the design and implementation of this Kafka-based data
flow layer are the following.</p>
<blockquote>
<div><ul class="simple">
<li>The Destinations and the Sources have assigned one topic. A Source
sends data to its topic while a Destination consumes data from
its topic.</li>
<li>Destinations can decide to consume its data in two ways:
by implementing a Kafka Consumer for its topic or by using
a REST API exposed by the HGF. The two options
are mutually exclusive.</li>
<li>The Destinations doesn’t know the Sources from which the data come
from, unless the Source itself inserts the information in the
data payload.</li>
<li>The Sources include the channel_id as the Kafka message key to allow
the HGW dispatcher to route the message
to the correct Destination.</li>
<li>The HGD uses the process_id as the Kafka message key to
allow the Destination to know to which person assign the message.</li>
<li>The HGD is unaware of the data that transit between a
Source and a Destination, since the payload of the message is
encrypted by the Source and only the Destination can decrypt it.
The only information that HGD knows is the Destination
to which route the message.</li>
</ul>
</div></blockquote>
<p>The architecture is described in the following diagram</p>
<blockquote>
<div><img alt="_images/kafka_based_hgw.svg" src="_images/kafka_based_hgw.svg" /></div></blockquote>
<div class="section" id="overall-data-exchange-process">
<h4>Overall data exchange process<a class="headerlink" href="#overall-data-exchange-process" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The following are the steps to transfer data from a Source to a Destination</p>
<ol class="arabic simple">
<li>The Source encrypts the data using the Destination public key
(see <a class="reference internal" href="#data-encryption-label"><span class="std std-ref">Data Encryption</span></a> for the details)</li>
<li>The Source sends a message to its topic (i.e., the topic with name
<cite>source_id</cite>) specifying the <cite>channel_id</cite> as the key</li>
<li>The HGD consume the message from the Source topic and
gets the <cite>channel_id</cite>.</li>
<li>The HGD queries the CM for the status of
the Channel</li>
<li>If the Channel is active the HGD queries the HGW
Frontend for the <cite>process_id</cite> related to the <cite>channel_id</cite></li>
<li>The HGD sends a message to the Destination’s topic
(i.e., the topic with name <cite>destination_id</cite>) specifying the
<cite>process_id</cite> as the message key</li>
<li>The HGD sends a message to the Destination’s topic
(i.e., the topic with name destination_id)
specifying the process_id as the message key.
The Destination gets the message from its topic and decrypts it
with its private key. It can consume messages directly from its topic
implementing a Kafka Consumer or it can use the REST API of the
HGF.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="id1">
<h4>Security<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>An important requirement of the Health Gateway is that the data transfer
from a Source to a Destination must be secure and the data must be read
only from the correct Destination; even the HGW must not be able to
read the sensitive data of a message. To achieve this goal, the Health
Gateway supports two levels of encryption:</p>
<p>SSL encryption to connect and send data to the Kafka Broker;
Encryption of data payload</p>
<p>With the first level of encryption it is guaranteed that messages
sent from a Kafka Producer (Source) or to a Kafka Consumer
(Destination) are encrypted: consequently, if they are intercepted
by an attacker they cannot be decrypted. This level is implemented
by Kafka itself using HTTPS protocol, so it’s just a matter of configuration.
Moreover, to guarantee that only the correct clients can access to a
specific topic, Kafka Broker is configured to use HTTPS client authentication
and Access Control List to the topics. When a Destination is configured to
consume messages as Kafka Consumer, the Kafka ACL permits only the
Destination’s Consumer to access its topic. In the case
of Destination is configured to use a REST API, the ACL is configured
to give access to the topic just to the HGF. In this case it is
guaranteed that only the correct Destination can get the data by using
the OAuth2 protocol: the REST API requires an OAuth2 access token,
which is associated to the Destination and so to the topic,
and so the HGF knows the correct topic to use when it
receives REST requests.</p>
<p>The second level of encryption guarantees that the data that go through
the HGW can be decrypted only from the correct Destination. During the
instantiation of a Channel, the Source is provided with the
Destination’s public key. When the Source sends a message it uses the
key to encrypt a symmetric key used in turn to encrypt the payload.
In this way the Destination, and only it, can decrypt the symmetric key
and then the message. Data encryption are described in details in
<a class="reference internal" href="#data-encryption-label"><span class="std std-ref">Data Encryption</span></a></p>
</div>
<div class="section" id="data-encryption">
<span id="data-encryption-label"></span><h4>Data Encryption<a class="headerlink" href="#data-encryption" title="Permalink to this headline">¶</a></h4>
<p>As said before the Source encrypts the data payload using the Destination
public key. What actually happens is that the data are encrypted using an
AES key which is encrypted itself using the RSA public key of the
Destination. So when the Destination receives a message, it gets the
RSA encrypted AES key, decrypts it using its private key and then
decrypts the message using the AES key. It is to be said that the RSA
decryption phase is computationally heavy, so it is possible to use the
same AES key for more than one message and send a hash of the key
included in the message. When the Destination receives the message,
it checks if the hash is the same as the message before: if it’s not it
decrypts the AES key and stores the hash and the key, otherwise it uses
the same key as before, avoiding the RSA decryption of the key. The policy
to use to change the AES key is left to the Source.</p>
<dl class="docutils">
<dt>The overall payload will be structured as follow:</dt>
<dd><ul class="first last">
<li><p class="first">2 MAGIC BYTES (0xdf 0xbb) they indicates if the message is encrypted
or not</p>
</li>
<li><p class="first">3 bytes indicating</p>
<blockquote>
<div><ul class="simple">
<li>the length of the AES key hash</li>
<li>RSA factor f so that f*128*8 evaluates to the RSA key size (in bits)</li>
<li>length of the AES initialization vector</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">AES hash</p>
</li>
<li><p class="first">RSA encrypted AES key</p>
</li>
<li><p class="first">Initialization vector</p>
</li>
<li><p class="first">AES encrypted message</p>
</li>
</ul>
</dd>
</dl>
<p>The methodology used is described in
<a class="reference external" href="https://blog.codecentric.de/en/2016/10/transparent-end-end-security-apache-kafka-part-1/">https://blog.codecentric.de/en/2016/10/transparent-end-end-security-apache-kafka-part-1/</a></p>
</div>
</div>
<div class="section" id="user-authentication">
<h3>User authentication<a class="headerlink" href="#user-authentication" title="Permalink to this headline">¶</a></h3>
<p>As explained before, the Health Gateway and the CM, delegate an
external service for user authentication. In fact they are implemented as
<a class="reference external" href="https://en.wikipedia.org/wiki/SAML_2.0">SAML2</a> Service Providers, so
they can easily be configured to use all standard Identity Providers.
In the pilot study, two services has been considered:</p>
<blockquote>
<div><ul class="simple">
<li>SPID (Sistema Pubblico di Identità Digitale): it is an Italian
service for digital identity used by the public administration
digital services and it is candidated to be used also at European
level. In the pilot implementation it has been used the
development docker image provided by AgID (Agenzia per l’Italia
Digitale)</li>
<li>TS/CNS (Tessera Sanitaria - Carta Nazionale dei Servizi): it is
another Italian authentication method that requires a client
certificate authentication. The certificate is provided by the
Italian Government to its citizens and it is embedded in a smartcard.</li>
</ul>
</div></blockquote>
<div class="section" id="spid">
<h4>SPID<a class="headerlink" href="#spid" title="Permalink to this headline">¶</a></h4>
<p>SPID is the Italian service for digital identity to access the public
administration services and to private services that wants to adhere.
It is implemented as a SAML2 Identity Provider. For testing and
development purposes, in the context of the pilot, two docker images have been
created (crs4/spid-testenv-identityservice and crs4/spid-testenv-backlog).
The docker images extend the docker images provided by
<a class="reference external" href="https://github.com/italia/spid-testenv-docker">AgID</a>.</p>
</div>
<div class="section" id="ts-cns">
<h4>TS/CNS<a class="headerlink" href="#ts-cns" title="Permalink to this headline">¶</a></h4>
<p>The TS/CNS is basically a standard
<a class="reference external" href="https://en.wikipedia.org/wiki/Client_certificate">client certificate</a>
authentication method. This method requires the client (i.e., the browser)
to present a client certificate signed by a Certification Authority recognized
by the web server, to access the website. In the case of TS/CNS the certificate
is embedded in a personal smart card given by the government to the citizens
and it is signed by one of regional Certification Authorities. In order to use
the certificate, the citizen needs a smart card reader to be configured in
his/her PC or browser.</p>
<p>In the pilot implementation, it has been created a
<a class="reference external" href="https://www.shibboleth.net">Shibboleth</a> docker image (crs4/tscns),
configured to use client certificate authentication with the regional
Certification Authorities which sign the citizens certificates.
For development purpose, the image can use also a development
certification authorities and client certificates
that can be created with the certs scripts.</p>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="modules/hgw_frontend/home.html" class="btn btn-neutral float-right" title="HGW Frontend" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Health Gateway Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, CRS4 - Center for Advanced Studies, Research and Development in Sardinia.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>